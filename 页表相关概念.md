# 1. 页表相关概念

## 1. mmu以及mmu的好处

mmu是memory management unit的缩写，即内存管理单元，负责将**虚拟地址转化为物理地址**，并进行**权限管理**。

mmu的好处：隔离用户地址空间与内核地址空间，隔离各个进程的地址空间。恶意进程不会访问到其他进程及内核的地址空间。

## 2. 什么是页表

将虚拟地址映射到物理地址的数据结构叫做页表，表项中存放的是虚拟地址中对应的**物理页帧号**和**访问权限**等信息。

## 3. 什么是tlb

类似于数据Cache与指令Cache，访问页表也会有页表缓存，TLB即页表缓存，缓存最近使用的页表项。

## 4. arm64页表管理相关寄存器

1. ttbr0_el1：转换表基址寄存器0，存放用户地址空间页表基地址。

![ttbr0_el1寄存器](E:\markdown\run_linux\page_table\image-20210215164917757.png)

`ASID`：进程空间标识符，标识是哪个进程的TLB表项，在进程LTB表查找的时候会用到。

2. sctlr_el1：系统控制寄存器，控制mmu使能。

![image-20210215165603502](E:\markdown\run_linux\page_table\image-20210215165603502.png)

`M位bit[0]`：MMU使EL1和EL0阶段地址转换使能位。

`I位bit[12]`：指令cache使能位

`C位bit[2]`：cache使能位，使能数据和统一cache

arm64在启动kernel阶段，存在数据cache和指令cache，数据cache必须关闭，指令cache可以关闭，也可不关闭。数据cache关闭是因为BootLoader可能有些数据已经缓存到数据cache中，所以需要关闭数据cache，防止影响启动内核代码。而指令cache可以关闭，也可不关闭，因为我们的BootLoader与kernel在不同的物理地址区域中，所以他们的指令和地址互不影响，加入到cache中也不会存在冲突。

3. TCR_EL1：转换控制寄存器，控制页表转换格式等

![image-20210215203553341](E:\markdown\run_linux\page_table\image-20210215203553341.png)

`AS位bit[36]`：ASID大小，是16位的还是8位的

`IPS位bit[34:32]`：中间物理地址大小，比如设置成48位。为什么是中间物理地址呢，如果支持虚拟化的话，需要从VA->IPA->PA，如果没有虚拟化，IPA=PA，如果有虚拟化，还需要从IPA转换到PA。

`TG1位bit[31:30]`：TTBR1_EL1粒度大小（一个页表大小），比如设置成4K。

`EPD1位bit[23]`：使用TTBR1时，tlb miss时转换表遍历使能。

`A1位bit[22]`：选择TTBR0_EL1或TTBR1_EL1来定义ASID。

# 2. arm64页表结构

## 1. arm64页表格式

1. arm64处理器将页表称为转换表，最多支持4级转换表（L0-L3），将表项称为描述符。
2. 支持3种页长度：4K、16K，64K。
3. 描述符的第0bit位表示描述符是否有效。1bit位表示描述符类型：L0-L2级转换表的第1bit位为0表示**块描述符**，为1表示**表描述符**；L3级转换表的第1bit位为0表示**保留描述符**，为1表示**页描述符**。**块描述符**表示该级转换表项不指向下级转换表，直接指向一块内存区（比如启动时的段映射，巨型页实现）。**表描述符**为正常中间各级页表项，它会指向下级页表。**页描述符**为最后一级转换表的表项，用于描述一个物理内存页。



## 2. 页表属性

arm64页表属性分为低位属性和高位属性，如下图所示：

![image-20210215212138649](E:\markdown\run_linux\page_table\image-20210215212138649.png)

`UXN or XN位bit[54]`：1表示在EL0（用户态空间）UXN，不允许EL0执行；0表示XN，用户态空间可执行。

`PXN位bit[53]`：PXN表示EL1（特权级）不可执行，即表示内核态是否对内存有可执行权限。

`Contiguous位bit[52]`：表示这条表项属于一个连续表项集合中的一个表项，连续表项集合可以被缓存在一条tlb表项中。可以实现巨型页。

`DBM位bit[51]`：脏位，表示页表项是否被修改。

`nG位bit[11]`：非全局，为1表示转换不是全局的，是进程私有，会关联一个ASID；为0表示转换是全局的，是所有进程共享，比如内核地址空间即全局共享的。

`AF位bit[10]`：访问标志，表示页或者内存块从对应的表项被清零后是否被访问过。

`AP位bit[9:8]`：数据访问权限，AP[2]选择读写权限：0可读可写，1只读。AP[1]选择el0/el1访问：0不可被el0访问，1可被el0访问。

## 3. 内存属性

arm64内存属性分为普通内存和设备内存。

1. normal memory：普通内存，如ddr，SRAM
2. device memory：设备内存，如内存映射IO寄存器，总是non cacheable的，而且是outer shareable。

外部共享与内部共享：

1. 所有的CPU core属于一个内部共享域（inner shareable domain）
2. 所有的CPU core和dma controller属于一个外部共享域（outer shareable domain）

一致性问题，与共享属性有关：

1. non-shareable：不会在多个CPU之间共享，不存在一致性问题。
2. inner-shareable：说明内部共享域中的所有CPU在对该内存进行数据访问时，硬件会保证一致性。
3. outer-shareable：说明外部共享域中的所有单元（CPU与DMA）在对该内存进行数据访问时，硬件会保证一致性。

两种模式：直写模式与回写模式（normal memory属性）：

1. write-through：直写模式，在数据更新时，同时写入缓存cache和后端存储。优点是操作简单；缺点是因为数据修改需要同时写入存储，数据写入速度较慢。
2. write-back：回写模式，在数据更新时只写入缓存cache。只在数据被替换出缓存时，被修改的缓存数据才会被写到后端存储。优点是数据写入速度快，因为不需要写存储；缺点是一旦更新后的数据未被写入存储时出现系统掉电的情况，数据将无法找回。

device memory附件属性：

1. Gathering或者non Gathering
2. Re-ordering或者non Re-ordering
3. Early Write Acknowledgement或者non

## 4. 内核中的页表属性

1. 内核页表属性
2. 设备页表属性
3. 用户进程页表属性

## 5. 页表对巨型页的支持

如果一个应用程序对内存的需求比较大，如果用一般粒度的页，那么会发生较多次的cache miss和缺页异常。为了减少访问大块内存对系统性能影响，就引入巨型页。

1. 块描述符支持巨型页

- 如果**页的大小为4K**，则使用4级转换表，L0级转换表不能使用块描述符，L1级转换表可以使用块描述符且指向1G巨型页，L2级转换表可以使用块描述符且指向2M的巨型页。
- 如果**页的大小为16K**，则使用4级转换表，L0级转换表不能使用块描述符，L1级转换表不能使用块描述符，L2级转换表可以使用块描述符且指向32M的巨型页。
- 如果**页的大小为64K**，则使用3级转换表，L0级转换表不能使用块描述符，L1级转换表不能使用块描述符，L2级转换表可以使用块描述符且指向512M的巨型页。

2. 块/页描述符连续位支持巨型页

块/页描述符的连续位表示的表项是一个表项集合中的一个表项，一个表项集合可以被缓存在一个tlb表项中。

- 如果**页的大小为4K**，则使用4级转换表，L0级转换表不能使用块描述符，L1级转换表的块描述符不能使用连续位，L2级转换表支持16个连续位，即是16x2M=32M的巨型页。L3级转换表支持16个连续位，即是16x4K=64K的巨型页。
- 如果**页的大小为16K**，则使用4级转换表，L2级转换表支持32个连续位，即是32x32M=1G的巨型页，L3级转换表支持128个连续位，即是128x16k=2M的巨型页。
- 如果**页的大小为64K**，则使用3级转换表，L2级转换表的块描述符不能使用连续位，L3级转换表支持32个连续位，即是32x64K=2M的巨型页。

# 3. 页表遍历过程

## 1. 页表遍历原理

linux 4.11之前，Linux内核将页表分为4级：

- 页全局目录（PGD）
- 页上级目录（PUD）
- 页中间目录（PMD）
- 直接页表（PT）

linux 4.11之后，将页表拓展到5级，在页全局目录和页上级目录之间增加了页四级目录（P4D）。各个处理器架构可以选择使用5级（pgd，p4d，pud，pmd，pt）、4级（pgd，pud，pmd，pt）、3级（pgd，pmd，pt）和2级（pgd，pt）页表，使用CONFIG_PAGETABLE_LEVELS来配置页表级数。



![image-20210215235827122](E:\markdown\run_linux\page_table\image-20210215235827122.png)

1. 首先在tlb中查找页表缓存是否存在，不存在往下走。
2. 根据虚拟地址VA的最高位判断使用TTBR0还是TTBR1获取PGD，bit[63]=1说明是内核态地址，应该使用TTBR1当PGD；bit[63]=0说明是用户态地址，应该使用TTBR1当PGD。
3. 逐级遍历页表，最后在L3级获取PTE，PTE中判断权限后即可获取物理页帧号。
4. 获取物理页帧号后，再加上VA[11:0]的offset，即可得到物理地址。

## 2. 内核中的遍历实现

缺页异常中遍历各级页表

# 4. TLB原理和操作

## 1. 相关概念

mmu把虚拟地址转化为物理地址，为了改进转化速度，避免每次都从内存查询多级页表，处理器厂商就在mmu中增加了一个称为TLB的高速缓存。

TLB是translation Lookaside Buffer的简称，意为转换旁路缓冲区，又称为块表，可以理解为页表缓存，用来缓存最近使用的页表项。

有些处理器有两级TLB，第一级TLB分为指令TLB和数据TLB，访问指令和数据可以并行执行；第二级TLB为统一的TLB（unified TLB），指令和数据公用TLB。

## 2. TLB原理

当CPU发出虚拟地址访问请求时，会经历如下四个过程：

![image-20210216215253145](E:\markdown\run_linux\page_table\image-20210216215253145.png)

1. MMU查询TLB，存在则TLB hit，得到物理地址；否则执行内存查找步骤。
2. 根据虚拟地址各段偏移加上PGD逐级遍历页表，得到物理地址。
3. 将页表项填充到TLB中，以备下次访问使得TLB hit；如果TLB已经满，则执行替换算法失效一部分TLB。
4. 得到物理地址后，首先从cache中读取，如果不存在则从内存中读取数据完成地址访问。

一次完成的TLB运行机制流程如下图所示：

![image-20210216214116546](E:\markdown\run_linux\page_table\image-20210216214116546.png)

1. TLB表中根据VA的index字段查询TLB表项
2. 判断V字段是否为有效TLB表项
3. 判断VA中的tag。
   - VA最高位为1，内核地址，nG位为0，无需关联ASID，校验VA与TLB表项中的tag是否一致，一致则TLB命中。
   - VA最高位为0，用户空间地址，nG位为1，需要关联ASID。
     1. 判断TTBRx_EL1中的ASID是否与TLB表项中ASID字段一致，进程切换是已经切换TTBRx_EL1中的ASID。一致则认为TLB命中，
4. 取出PTE，根据PTE中的页表属性校验访问权限，通过后加上offset即可得到物理地址。
5. TLB表项中包含五个字段：
   - V：标识TLB是否有效，1为有效，0为无效，如果无效，则继续遍历多级页表后再填充TLB。
   - ASID：ASID是对TLB的一个优化，当进程由A切换B时，TLB表项中可能还存在A进程的TLB表项，且可能是缓存这与B进程同一个VA的PTE。如果没有ASID，则由A切换B时，需要失能所有的TLB表项，对于B进程访问地址重新填充TLB表项。有了ASID之后，就不需要失能所有的TLB表项，只有当ASID满了之后，才无效TLB表项。ASID就是地址空间标识符。每一个进程都对应一个ASID号，从而标识TLB表项归属于一个进程。
   - nG：非全局位，为1则是非全局，为进程私有，需要关联ASID。为0则是全局的内核TLB，不需要关联ASID。
   - Tag：来自于VA里面的tag，进行VA的TLB查询时，首先判断VA最高位，为1的话是内核地址；为0的话就是用户空间地址。如果是内核空间地址，则nG位为0，无需关联ASID。

## 3. TLB操作

内核中如果修改了缓存在TLB中的表项（也就是更改了页表项，因为TLB中也是缓存了页表项），那么内核需要使旧的TLB表项无效（invalidate tlb或者flush tlb）也就是是V字段为0。

## 4. flush tlb的arm64实现

当tlb miss时，ARM64处理器架构的mmu会自动遍历内存中的各级页表，然后将页表项缓存到tlb中，不需要软件去写页表项到tlb中，所以arm64没有写tlb指令，但是提供将tlb表项无效的指令：

# 5. ASID机制

## 1. 相关概念

ASID：Address Space Identifier的缩写，是为了减少在进程切换是清空tlb的操作。arm64处理器在tlb中增加了nG位区别内核和用户进程的页表项，使用ASID区别不用的用户进程的页表项。

注释：ASID机制存在之前，由于进程切换时可能存在上一个进程的tlb表项，所以需要清空tlb，被切换的进程获得一个全空的tlb，这样进程地址转换需要遍历多级页表，极大的影响系统性能。

ASID的长度：arm64处理器可以选择8bit或者16bit长度。

ASID的存放位置：保存到进程的task_struct的mm->contex->id中。

## 2. ASID机制实现原理

代码分析

## 3. 实例讲解ASID机制

![image-20210216231158596](E:\markdown\run_linux\page_table\image-20210216231158596.png)

- 新创建进程E，初始化的ASID为0，软件ASID版本号为0。
- 当切换至进程E时，需要分配ASID，发现无空闲ASID。
- 则系统ASID版本号由800加一变成801，同时进行如下操作：
  - 清空asid_map，表示ASID已分配满，清空分配记录。
  - 清空CPU的tlb

- 分配E进程ASID为1。
- 切换至进程B，发现B的ASID版本号与系统ASID版本号不一致，则需要为进程B分配ASID。但是B已经分配了ASID为5，同时5在当前801的asid_map中未分配掉，所以只需要更新B的ASID版本号。
- 切换至进程A，发现B的ASID版本号与系统ASID版本号不一致，则需要分配ASID。同时进程A的原分配ASID为1已经在801版本中被分配掉，所以需要同时更新ASID版本号为801，新分配ASID为6。

# 6. Linux内核页表操作相关定义

1. 表项数据类型定义：

- pgt_t
- p4d_t
- pud_t
- pmd_t
- pte_t

eg:

```c
typedef u64 pgdval_t;
typedef struct {pgdval_t pgd;} pgd_t;
```

2. 类型转换

- pxd_val()//pxd_t转化为u64
- __pxd()//u64转化为pxd_t

eg:

```c
#define pte_val(x)	((x).pte)
#define __pte(x)	((pte_t){(x)})
```

3. 表项大小定义

- XXX_SHIFT	表示各级页表索引在虚拟地址中的偏移
- XXX_SIZE       表示各级页表表项描述的地址空间大小
- XXX_MASK    表示各级页表屏蔽位掩码
- PTRS_PER_XXX     表示各级页表存在的表项个数
- pgd pud pmd pte单个表项分别映射大小为512G 1G 2M 4k内存
- pgd页目录包含512个表项，映射512 x 512G=256T

4. 获得表项索引

XXX_index	从虚拟地址中分解出XXX索引

```c
#define pmd_index(addr)	(((addr) >> PMD_SHIFT)&(PTRS_PER_PMD - 1))
```

5. 获得表项地址

XXX_offset    从指定的地址空间/目录表中获得XXX表项地址（页表首地址）

```c
#define	pud_offset(dir, addr)	((pud_t *)__va(pud_offset_phys((dir), (addr))))	
#define pgd_offset_k(addr)	pgd_offset(&init_mm, addr)
```

# 7. 启动阶段早期的页表创建

## 1. 建立恒等映射

早期启动代码：`arch/arm64/kernel/head.S`

```assembly
ENTRY(stext)
	bl	preserve_boot_args
	bl	el2_setup			// Drop to EL1, w20=cpu_boot_mode
	adrp	x24, __PHYS_OFFSET
	bl	set_cpu_boot_mode_flag
	bl	__create_page_tables		// x25=TTBR0, x26=TTBR1
	/*
	 * The following calls CPU setup code, see arch/arm64/mm/proc.S for
	 * details.
	 * On return, the CPU will be ready for the MMU to be turned on and
	 * the TCR will have been set.
	 */
	ldr	x27, =__mmap_switched		// address to jump to after
						// MMU has been enabled
	adr_l	lr, __enable_mmu		// return (PIC) address
	b	__cpu_setup			// initialise processor
ENDPROC(stext)
```

早期创建页表为段映射，实际使用3级页表结构，pgd->pud->pmd，一个表项映射2M；init_pd_dir为内核镜像做段映射的pgd页目录地址，会保存到ttbr1_el1寄存器中。

# 8. fixmap映射

内核初始化早期，内核已经运行在虚拟地址上，建立恒等映射和粗粒度内核页表映射只能保证内核镜像可以正常访问，这个时候如何访问BootLoader传递过来的dtb呢？这个时候内存管理子系统还没准备好，如何通过ioremap访问外设寄存器呢？为此kernel提出fixmap机制。